{"version":3,"file":"lesson13-hri6OJFI.js","sources":["../../src/scripts/lesson13.js"],"sourcesContent":["import * as THREE from 'three'\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\nimport GUI from 'lil-gui'\n\n/**\n * Particle is a plane composed with 2 triangles\n * and this mesh always rotated on camera\n * we will need BufferGeometry and PointsMaterial\n * and Points instance\n */\n\n\n\n/**\n * Base\n */\n// Debug\nconst gui = new GUI()\n\n// Canvas\nconst canvas = document.querySelector('canvas.webgl')\n\n// Scene\nconst scene = new THREE.Scene()\n\n/**\n * Textures\n */\nconst textureLoader = new THREE.TextureLoader()\n\n/**\n * Generate Particles:\n */\n//Geometry\nconst particlesGeometry = new THREE.BufferGeometry();\nconst count = 2000;\n\nconst positions = new Float32Array(count * 3);\nconst colors = new Float32Array(count * 3); \n\nfor (let i = 0; i < count * 3; i++) {\n    positions[i] = (Math.random() - 0.5) * 10; // fill sphere coordinates for each particle\n    colors[i] = Math.random(); // fill colors for each particle\n     \n    for (let i = 0; i < count; i++) {\n        const radius = Math.random() * 5;\n        const theta = Math.random() * 2 * Math.PI;\n        const phi = Math.acos((Math.random() * 2) - 1);\n\n        const x = radius * Math.sin(phi) * Math.cos(theta);\n        const y = radius * Math.sin(phi) * Math.sin(theta);\n        const z = radius * Math.cos(phi);\n\n        positions[i * 3] = x;\n        positions[i * 3 + 1] = y;\n        positions[i * 3 + 2] = z;\n    }\n}\n\n// particles positions need to be stored in a buffer attribute\n// particles \nparticlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));\nparticlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n\n// Material\nconst particlesMaterial = new THREE.PointsMaterial({\n    size: 0.05,\n    color: 0xff88cc,\n    sizeAttenuation: true, // create perspective effect\n    transparent: true,\n});\n\nparticlesMaterial.vertexColors = true; // enable vertex colors from COLORS buffer attribute\n\n// These textures are resized versions of the pack provided by Kenney and you can find \n// the full pack here: https://www.kenney.nl/assets/particle-pack. But you can also create your own.\nparticlesMaterial.alphaMap = textureLoader.load('/textures/particles/1.png');\n\n\n\n// Alpha map work incorrectly, the black background is visible\n\n//fix 1\n// particlesMaterial.alphaTest = 0.1; // remove the black background from alphaMap texture. blurring\n// particlesMaterial.map = textureLoader.load('/textures/particles/1.png');\n\n//fix 2\n// deactivating the depth test could create a problem with the rendering order of other objects in the scene\n// particlesMaterial.depthTest = false; // remove the black background from alphaMap texture. blurring\n\n// fix 3\n// the depth of what's being drawn is stored in the depth buffer. Instead of not testings the depth, we can just not write to it.\n// THE BEST SOLUTION\nparticlesMaterial.depthWrite = false; // remove the black background from alphaMap texture. blurring\n\n\n// the webgl currently draws pixels one on top of the other.\n// With blending we can create the additive effect - to add the color of the pixel to the color which already drawn\n// but this could impact performance\nparticlesMaterial.blending = THREE.AdditiveBlending; // add blending mode to create the additive effect\n\n\n\n// Draw Points\nconst particles = new THREE.Points(particlesGeometry, particlesMaterial);\n\nscene.add(particles);\n\n\n/**\n * Sizes\n */\nconst sizes = {\n    width: window.innerWidth,\n    height: window.innerHeight\n}\n\nwindow.addEventListener('resize', () =>\n{\n    // Update sizes\n    sizes.width = window.innerWidth\n    sizes.height = window.innerHeight\n\n    // Update camera\n    camera.aspect = sizes.width / sizes.height\n    camera.updateProjectionMatrix()\n\n    // Update renderer\n    renderer.setSize(sizes.width, sizes.height)\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\n})\n\n/**\n * Camera\n */\n// Base camera\nconst camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)\ncamera.position.z = 3\nscene.add(camera)\n\n// Controls\nconst controls = new OrbitControls(camera, canvas)\ncontrols.enableDamping = true\n\n/**\n * Renderer\n */\nconst renderer = new THREE.WebGLRenderer({\n    canvas: canvas\n})\nrenderer.setSize(sizes.width, sizes.height)\nrenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\n\n/**\n * Animate\n */\nconst clock = new THREE.Clock()\n\nconst tick = () =>\n{\n    const elapsedTime = clock.getElapsedTime()\n\n\n    // Animate particles here one by one in the loop\n    // is good for small amount of particles\n    // but for large amount of particles we need to use a CUSTOM SHADER\n    // Update particles\n    // particles.rotation.y = elapsedTime * 0.1\n\n    for (let i = 0; i < count; i++) {\n        const i3 = i * 3;\n\n        // particlesGeometry contains the positions of all particles\n\n        const x = particlesGeometry.attributes.position.array[i3];\n        // const y = particlesGeometry.attributes.position.array[i3 + 1];\n        // const z = particlesGeometry.attributes.position.array[i3 + 2];\n\n        particlesGeometry.attributes.position.array[i3 + 1] = Math.sin(elapsedTime + x);\n    }\n\n    particlesGeometry.attributes.position.needsUpdate = true; // TELL THREE.JS THAT THE POSITION ATTRIBUTE HAS BEEN UPDATED!!!\n\n    // Update controls\n    controls.update()\n\n    // Render\n    renderer.render(scene, camera)\n\n    // Call tick again on the next frame\n    window.requestAnimationFrame(tick)\n}\n\ntick()"],"names":["GUI","canvas","scene","THREE.Scene","textureLoader","THREE.TextureLoader","particlesGeometry","THREE.BufferGeometry","count","positions","colors","i","radius","theta","phi","x","y","z","THREE.BufferAttribute","particlesMaterial","THREE.PointsMaterial","THREE.AdditiveBlending","particles","THREE.Points","sizes","camera","renderer","THREE.PerspectiveCamera","controls","OrbitControls","THREE.WebGLRenderer","clock","THREE.Clock","tick","elapsedTime","i3"],"mappings":"2OAiBY,IAAIA,EAGhB,MAAMC,EAAS,SAAS,cAAc,cAAc,EAG9CC,EAAQ,IAAIC,EAKZC,EAAgB,IAAIC,EAMpBC,EAAoB,IAAIC,EACxBC,EAAQ,IAERC,EAAY,IAAI,aAAaD,EAAQ,CAAC,EACtCE,EAAS,IAAI,aAAaF,EAAQ,CAAC,EAEzC,QAAS,EAAI,EAAG,EAAIA,EAAQ,EAAG,IAAK,CAChCC,EAAU,CAAC,GAAK,KAAK,OAAQ,EAAG,IAAO,GACvCC,EAAO,CAAC,EAAI,KAAK,OAAM,EAEvB,QAASC,EAAI,EAAGA,EAAIH,EAAOG,IAAK,CAC5B,MAAMC,EAAS,KAAK,OAAM,EAAK,EACzBC,EAAQ,KAAK,OAAQ,EAAG,EAAI,KAAK,GACjCC,EAAM,KAAK,KAAM,KAAK,OAAQ,EAAG,EAAK,CAAC,EAEvCC,EAAIH,EAAS,KAAK,IAAIE,CAAG,EAAI,KAAK,IAAID,CAAK,EAC3CG,EAAIJ,EAAS,KAAK,IAAIE,CAAG,EAAI,KAAK,IAAID,CAAK,EAC3CI,EAAIL,EAAS,KAAK,IAAIE,CAAG,EAE/BL,EAAUE,EAAI,CAAC,EAAII,EACnBN,EAAUE,EAAI,EAAI,CAAC,EAAIK,EACvBP,EAAUE,EAAI,EAAI,CAAC,EAAIM,CAC/B,CACA,CAIAX,EAAkB,aAAa,WAAY,IAAIY,EAAsBT,EAAW,CAAC,CAAC,EAClFH,EAAkB,aAAa,QAAS,IAAIY,EAAsBR,EAAQ,CAAC,CAAC,EAG5E,MAAMS,EAAoB,IAAIC,EAAqB,CAC/C,KAAM,IACN,MAAO,SACP,gBAAiB,GACjB,YAAa,EACjB,CAAC,EAEDD,EAAkB,aAAe,GAIjCA,EAAkB,SAAWf,EAAc,KAAK,2BAA2B,EAiB3Ee,EAAkB,WAAa,GAM/BA,EAAkB,SAAWE,EAK7B,MAAMC,EAAY,IAAIC,EAAajB,EAAmBa,CAAiB,EAEvEjB,EAAM,IAAIoB,CAAS,EAMnB,MAAME,EAAQ,CACV,MAAO,OAAO,WACd,OAAQ,OAAO,WACnB,EAEA,OAAO,iBAAiB,SAAU,IAClC,CAEIA,EAAM,MAAQ,OAAO,WACrBA,EAAM,OAAS,OAAO,YAGtBC,EAAO,OAASD,EAAM,MAAQA,EAAM,OACpCC,EAAO,uBAAsB,EAG7BC,EAAS,QAAQF,EAAM,MAAOA,EAAM,MAAM,EAC1CE,EAAS,cAAc,KAAK,IAAI,OAAO,iBAAkB,CAAC,CAAC,CAC/D,CAAC,EAMD,MAAMD,EAAS,IAAIE,EAAwB,GAAIH,EAAM,MAAQA,EAAM,OAAQ,GAAK,GAAG,EACnFC,EAAO,SAAS,EAAI,EACpBvB,EAAM,IAAIuB,CAAM,EAGhB,MAAMG,EAAW,IAAIC,EAAcJ,EAAQxB,CAAM,EACjD2B,EAAS,cAAgB,GAKzB,MAAMF,EAAW,IAAII,EAAoB,CACrC,OAAQ7B,CACZ,CAAC,EACDyB,EAAS,QAAQF,EAAM,MAAOA,EAAM,MAAM,EAC1CE,EAAS,cAAc,KAAK,IAAI,OAAO,iBAAkB,CAAC,CAAC,EAK3D,MAAMK,EAAQ,IAAIC,EAEZC,EAAO,IACb,CACI,MAAMC,EAAcH,EAAM,eAAc,EASxC,QAASpB,EAAI,EAAGA,EAAIH,EAAOG,IAAK,CAC5B,MAAMwB,EAAKxB,EAAI,EAITI,EAAIT,EAAkB,WAAW,SAAS,MAAM6B,CAAE,EAIxD7B,EAAkB,WAAW,SAAS,MAAM6B,EAAK,CAAC,EAAI,KAAK,IAAID,EAAcnB,CAAC,CACtF,CAEIT,EAAkB,WAAW,SAAS,YAAc,GAGpDsB,EAAS,OAAM,EAGfF,EAAS,OAAOxB,EAAOuB,CAAM,EAG7B,OAAO,sBAAsBQ,CAAI,CACrC,EAEAA,EAAI"}