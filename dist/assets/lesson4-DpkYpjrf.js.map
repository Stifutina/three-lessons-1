{"version":3,"file":"lesson4-DpkYpjrf.js","sources":["../../src/scripts/lesson4.js"],"sourcesContent":["import * as THREE from 'three'\nimport { OrbitControls } from 'three/examples/jsm/Addons.js';\n\n// Canvas\nconst canvas = document.querySelector('canvas.webgl')\n\n// Scene\nconst scene = new THREE.Scene()\n\n\n/**\n * Cursor\n */\n\nconst cursor = {\n    x: 0,\n    y: 0\n};\n\n\n/**\n * Sizes\n */\nconst sizes = {\n    width: window.innerWidth,\n    height: window.innerHeight\n}\n\n/**\n * Object\n */\nconst geometry = new THREE.BoxGeometry(1, 1, 1)\nconst material = new THREE.MeshBasicMaterial({ color: 0xff0000 })\nconst mesh = new THREE.Mesh(geometry, material)\nscene.add(mesh);\n\n// mesh.position.set(1, 0.07, 0.5);\nmesh.position.normalize(); // put to 1 1 1 \n\n// mesh.scale.set(1.2, 1.1, 0.8);\n\nmesh.rotation.reorder('YXZ'); // order of setting, rotate by y then by x.\n// mesh.rotation.set(Math.PI * 0.25, Math.PI * 0.25, 0);\n// better to use quaternion because of rotation order\n\n\n/**\n * Camera\n * fov is a vertival angle of view, should be between 45 and 75.\n * \n */\n\nconst camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100);\n// const aspectRatio = sizes.width / sizes.height;\n// const camera = new THREE.OrthographicCamera(-1 * aspectRatio, 1 * aspectRatio, 1, -1, 0.1, 100); // if size of orthographic camera is square, the renderer size should be also square\n// far value should not be very far, because there will be glitches bugs because of z fighting\ncamera.position.z = 2;\n\nscene.add(camera);\n\n/**\n * Controls\n */\nconst controls = new OrbitControls(camera, canvas);\ncontrols.enableDamping = true;\n\n// controls.enabled = false;\n// controls.target.y = 2;\n// controls.update();\n\n\n/**\n * Renderer\n */\nconst renderer = new THREE.WebGLRenderer({\n    canvas: canvas\n})\nrenderer.setSize(sizes.width, sizes.height)\nrenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n\n\nwindow.addEventListener('mousemove', (event) => {\n    cursor.x = event.clientX / sizes.width - 0.5;\n    cursor.y = event.clientY / sizes.height - 0.5;\n});\n\nwindow.addEventListener('resize', () => {\n    // Update sizes\n\n    sizes.width = window.innerWidth;\n    sizes.height = window.innerHeight;\n\n    // Update camera\n\n    camera.aspect = sizes.width / sizes.height;\n    camera.updateProjectionMatrix();\n    renderer.setSize(sizes.width, sizes.height);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n});\n\nwindow.addEventListener('dblclick', () => {\n    const fullscreenElement = document.fullscreenElement || document.webkitFullScreenelement;\n\n    if (!fullscreenElement) {\n        if (canvas.requestFullscreen) {\n            canvas.requestFullscreen();\n        } else if (canvas.webkitRequestFullscreen) {\n            canvas.webkitRequestFullscreen();\n        }\n        \n    } else {\n        if (document.exitFullscreen) {\n            document.exitFullscreen();\n        } else if (document.webkitExitFullscreen) {\n            document.webkitExitFullscreen();\n        }\n        \n    }\n})\n\n/**\n * Animations\n * tick - a function which will be called on every next free frame \n * V1 with delta time\n */\n// let prevTime = Date.now();\n\nconst tick = () => {\n    // problem: the higher frame rate - the faster animation\n    // solution - check time\n\n    // const currentTime = Date.now();\n    // const deltaTime = currentTime - prevTime;\n    // prevTime = currentTime;\n    // mesh.rotation.y += 0.001 * deltaTime;\n\n\n\n    // Control camera by cursor:\n    // !! Controls is about the controlling and update camera by user actions\n\n    //move camera by cursor:\n    // camera.position.x = cursor.x * 10; // to follow camera by the cursor posiiton\n    // camera.position.y = cursor.y * -10;\n    \n    // camera.position.x = Math.sin(cursor.x * Math.PI * 2) * 3; // to turn camera horizontally around the scene with cursor position (x and z is horizontal plane)\n    // camera.position.z = Math.cos(cursor.x * Math.PI * 2) * 3;\n    // camera.position.y = cursor.y;\n    // camera.lookAt(mesh.position);\n\n\n    // Update controls to apply damping acceleration effect\n    controls.update();\n\n    // take a picture\n    renderer.render(scene, camera);\n    window.requestAnimationFrame(tick);\n}\n\ntick();\n"],"names":["canvas","scene","THREE.Scene","sizes","geometry","THREE.BoxGeometry","material","THREE.MeshBasicMaterial","mesh","THREE.Mesh","camera","THREE.PerspectiveCamera","controls","OrbitControls","renderer","THREE.WebGLRenderer","event","tick"],"mappings":"8JAIA,MAAMA,EAAS,SAAS,cAAc,cAAc,EAG9CC,EAAQ,IAAIC,EAgBZC,EAAQ,CACV,MAAO,OAAO,WACd,OAAQ,OAAO,WACnB,EAKMC,EAAW,IAAIC,EAAkB,EAAG,EAAG,CAAC,EACxCC,EAAW,IAAIC,EAAwB,CAAE,MAAO,QAAU,CAAA,EAC1DC,EAAO,IAAIC,EAAWL,EAAUE,CAAQ,EAC9CL,EAAM,IAAIO,CAAI,EAGdA,EAAK,SAAS,YAIdA,EAAK,SAAS,QAAQ,KAAK,EAW3B,MAAME,EAAS,IAAIC,EAAwB,GAAIR,EAAM,MAAQA,EAAM,OAAQ,GAAK,GAAG,EAInFO,EAAO,SAAS,EAAI,EAEpBT,EAAM,IAAIS,CAAM,EAKhB,MAAME,EAAW,IAAIC,EAAcH,EAAQV,CAAM,EACjDY,EAAS,cAAgB,GAUzB,MAAME,EAAW,IAAIC,EAAoB,CACrC,OAAQf,CACZ,CAAC,EACDc,EAAS,QAAQX,EAAM,MAAOA,EAAM,MAAM,EAC1CW,EAAS,cAAc,KAAK,IAAI,OAAO,iBAAkB,CAAC,CAAC,EAG3D,OAAO,iBAAiB,YAAcE,GAAU,CACjCA,EAAM,QAAUb,EAAM,MAAQ,GAC9Ba,EAAM,QAAUb,EAAM,OAAS,EAC9C,CAAC,EAED,OAAO,iBAAiB,SAAU,IAAM,CAGpCA,EAAM,MAAQ,OAAO,WACrBA,EAAM,OAAS,OAAO,YAItBO,EAAO,OAASP,EAAM,MAAQA,EAAM,OACpCO,EAAO,uBAAwB,EAC/BI,EAAS,QAAQX,EAAM,MAAOA,EAAM,MAAM,EAC1CW,EAAS,cAAc,KAAK,IAAI,OAAO,iBAAkB,CAAC,CAAC,CAC/D,CAAC,EAED,OAAO,iBAAiB,WAAY,IAAM,CACZ,SAAS,mBAAqB,SAAS,wBAUzD,SAAS,eACT,SAAS,eAAgB,EAClB,SAAS,sBAChB,SAAS,qBAAsB,EAV/Bd,EAAO,kBACPA,EAAO,kBAAmB,EACnBA,EAAO,yBACdA,EAAO,wBAAyB,CAW5C,CAAC,EASD,MAAMiB,EAAO,IAAM,CAyBfL,EAAS,OAAQ,EAGjBE,EAAS,OAAOb,EAAOS,CAAM,EAC7B,OAAO,sBAAsBO,CAAI,CACrC,EAEAA,EAAM"}